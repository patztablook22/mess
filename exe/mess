#! /usr/bin/env ruby
# frozen_string_literal: true

require 'io/console'
require 'slop'
require_relative '../lib/mess'

$listing = Array.new

begin
  opts = Slop.parse do |o|

    o.banner = "usage: #{$0} [options] target"

    o.on '--help', 'print help' do
      puts o
      exit
    end

    o.on '--version', 'print version' do
      puts Mess::VERSION
      exit
    end

    o.string '--output', '-o', 'output file'

    o.bool '--archived', '-a', 'archived threads too', default: false

    o.bool '--list', '-l', 'listing mode'

    o.array '--chat', '-c', 'chat specification' do
      $listing << :chats
    end

    o.array '--plot', '-p', 'plot specification' do
      $listing << :plots
    end

  end
rescue Slop::MissingArgument => e
  p e.message
rescue Slop::UnknownOption => e
  puts e
  exit 1
end

target = opts&.arguments || Array.new
target << '.' if target.none?

if target.one?
  target = target.first
else
  $stderr.puts 'too many targets'
  exit 1
end

def list_chats tree
  puts "chats"
  tree.chats.each_with_index do |chat, index|
    index += 1
    index  = index.to_s.rjust(5)
    puts "#{index} | #{chat.title}"
  end
end

def list_plots plots
  puts "plots"
  index = 1
  plots.available.each_pair do |name, desc|
    puts "#{index.to_s.rjust(5)} | #{name.ljust(15)} -> #{desc}"
    index += 1
  end
end

# listing mode
if opts.list?

  # chats
  if $listing.include? :chats
    begin
      tree = Mess::Tree.new(target)
      puts
      list_chats tree
    rescue Mess::TreeInvalidError
      $stderr.puts "not an archive: #{target}"
      exit 1
    end
  end

  # plots
  if $listing.include? :plots
    puts
    list_plots Mess::Plot
  end

  # none
  if $listing.none?
    $stderr.puts 'no specification flag for listing'
    exit 1
  end

  puts
  exit

end

begin

  # given directly chat
  chat = Mess::Chat.new(target)

rescue Mess::ChatInvalidError

  # given tree
  begin
    tree = Mess::Tree.new(target, archived: opts.archived?)
  rescue Mess::TreeInvalidError
    $stderr.puts "not a chat/archive: #{target}"
    exit 1
  end

  # select chat
  input  = opts[:chat].join
  chat   = nil
  failed = false
  loop do

    # search for nick or index
    chat   = tree.chats.find { |c| c.title == input }
    chat ||= tree.chats[input.to_i - 1] if input.to_i.to_s == input and (1..tree.chats.size).include? input.to_i
    unless chat.nil?
      puts if failed
      break
    end

    # failed
    puts
    list_chats tree unless failed
    failed = true

    print 'select> '
    input = $stdin.gets.chomp

  end

end

# select plot
input  = opts[:plot]
plot   = nil
failed = false
loop do

  # map indexes to names
  input.map! do |p|
    if p.to_i.to_s == p and (1..Mess::Plot.available.size).include? p.to_i
      Mess::Plot.available.keys[p.to_i - 1]
    else
      p
    end
  end

  # validate names
  if input.any? and input.all? { |p| Mess::Plot.available.include? p }
    plot = Set.new(input)
    puts if failed
    break
  end

  # failed
  puts
  list_plots Mess::Plot unless failed
  failed = true
  print 'select> '
  input = $stdin.gets.strip.split(/[, ]/).compact

end

# prepare
puts 'preparing...'
plot.map! do |p|
  Mess.const_get(p).new(chat)
end
$stdout.cursor_up 1
puts 'preparing... done'

# analyze
total = chat.count
pcapx = total / 100
check = 0
puts
chat.msgs.each_with_index do |m, i|
  if i >= check
    $stdout.cursor_up 1
    puts "analyzing... #{100 * i / total}%"
    check += pcapx
  end
  plot.each do |p|
    #p.push m
  end
end
$stdout.cursor_up 1
puts "analyzing... done"

# review
puts
plot.each_with_index do |p, i|
  $stdout.cursor_up 1
  puts "reviewing... #{i + 1}/#{plot.size}"
  p.review
end
$stdout.cursor_up 1
puts "reviewing... done"
